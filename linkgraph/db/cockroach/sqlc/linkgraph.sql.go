// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: linkgraph.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const edgesInPartition = `-- name: EdgesInPartition :many
SELECT id, src, dst, updated_at FROM edges WHERE src >= $1 AND dst < $2 AND updated_at < $3
`

type EdgesInPartitionParams struct {
	Src       uuid.UUID    `json:"src"`
	Dst       uuid.UUID    `json:"dst"`
	UpdatedAt sql.NullTime `json:"updated_at"`
}

func (q *Queries) EdgesInPartition(ctx context.Context, arg EdgesInPartitionParams) ([]Edges, error) {
	rows, err := q.db.QueryContext(ctx, edgesInPartition, arg.Src, arg.Dst, arg.UpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Edges
	for rows.Next() {
		var i Edges
		if err := rows.Scan(
			&i.ID,
			&i.Src,
			&i.Dst,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findLink = `-- name: FindLink :many
SELECT url, retrieved_at FROM links WHERE id=$1
`

type FindLinkRow struct {
	Url         sql.NullString `json:"url"`
	RetrievedAt sql.NullTime   `json:"retrieved_at"`
}

func (q *Queries) FindLink(ctx context.Context, id uuid.UUID) ([]FindLinkRow, error) {
	rows, err := q.db.QueryContext(ctx, findLink, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindLinkRow
	for rows.Next() {
		var i FindLinkRow
		if err := rows.Scan(&i.Url, &i.RetrievedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linksInPartition = `-- name: LinksInPartition :many
SELECT id, url, retrieved_at FROM links WHERE id >= $1 AND id < $2 AND retrieved_at < $3
`

type LinksInPartitionParams struct {
	ID          uuid.UUID    `json:"id"`
	ID_2        uuid.UUID    `json:"id_2"`
	RetrievedAt sql.NullTime `json:"retrieved_at"`
}

func (q *Queries) LinksInPartition(ctx context.Context, arg LinksInPartitionParams) ([]Links, error) {
	rows, err := q.db.QueryContext(ctx, linksInPartition, arg.ID, arg.ID_2, arg.RetrievedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Links
	for rows.Next() {
		var i Links
		if err := rows.Scan(&i.ID, &i.Url, &i.RetrievedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeStaleEdges = `-- name: RemoveStaleEdges :exec
DELETE FROM edges WHERE src=$1 AND updated_at < $2
`

type RemoveStaleEdgesParams struct {
	Src       uuid.UUID    `json:"src"`
	UpdatedAt sql.NullTime `json:"updated_at"`
}

func (q *Queries) RemoveStaleEdges(ctx context.Context, arg RemoveStaleEdgesParams) error {
	_, err := q.db.ExecContext(ctx, removeStaleEdges, arg.Src, arg.UpdatedAt)
	return err
}

const upsertEdge = `-- name: UpsertEdge :one
INSERT INTO edges (src, dst, updated_at) VALUES ($1, $2, NOW())
ON CONFLICT (src,dst) DO UPDATE SET updated_at=NOW()
RETURNING id, updated_at
`

type UpsertEdgeParams struct {
	Src uuid.UUID `json:"src"`
	Dst uuid.UUID `json:"dst"`
}

type UpsertEdgeRow struct {
	ID        uuid.UUID    `json:"id"`
	UpdatedAt sql.NullTime `json:"updated_at"`
}

func (q *Queries) UpsertEdge(ctx context.Context, arg UpsertEdgeParams) (UpsertEdgeRow, error) {
	row := q.db.QueryRowContext(ctx, upsertEdge, arg.Src, arg.Dst)
	var i UpsertEdgeRow
	err := row.Scan(&i.ID, &i.UpdatedAt)
	return i, err
}

const upsertLink = `-- name: UpsertLink :one
INSERT INTO links (url, retrieved_at) VALUES ($1, $2) 
ON CONFLICT (url) DO UPDATE SET retrieved_at=GREATEST(links.retrieved_at, $2)
RETURNING id, retrieved_at
`

type UpsertLinkParams struct {
	Url         sql.NullString `json:"url"`
	RetrievedAt sql.NullTime   `json:"retrieved_at"`
}

type UpsertLinkRow struct {
	ID          uuid.UUID    `json:"id"`
	RetrievedAt sql.NullTime `json:"retrieved_at"`
}

func (q *Queries) UpsertLink(ctx context.Context, arg UpsertLinkParams) (UpsertLinkRow, error) {
	row := q.db.QueryRowContext(ctx, upsertLink, arg.Url, arg.RetrievedAt)
	var i UpsertLinkRow
	err := row.Scan(&i.ID, &i.RetrievedAt)
	return i, err
}
